# What

1. 만약 내가 블록체인 네트워크에서 노드를 키면서(운영하면서) 사용자의 **블록 데이터 조회**를 빠르게 응답해주고 싶다.
2. 또한, 이 경우에 매 번 네트워크(혹은 관련 인프라 서비스 API)에 조회(요청)을 하는 것이 아닌 **블록 데이터 DB를 사전에 구축**해놓아 여기서 조회를 하거나 한다.
3. 사전 조건을 종합하여 **정확하게(1)**, 그리고 **빠르게(2)** 사용자에게 데이터를 전달하고 싶으면 어떻게 DB를 설계하고, 어떤 요청 로직을 짜야할까?

# Branch

1. 정확하게

- 사용자에게 전달되는 블록체인 데이터는 틀려서는 안된다.(오류가 있어서는 안된다.)
- 즉, 네트워크에서 가져온 블록 데이터가 정상적인 데이터인지 확인하는 과정이 필요하다.
  - ex) 특정 해시로 네트워크에 데이터를 재호출하여 동일 데이터인지 검증.
- 그렇게 잘 가져온 데이터를 **DB에 저장**해야한다. 아무리 네트워크에서 데이터를 잘 가져왔다고 하여도 잘못 저장하고, 이를 조회한다면 틀린 데이터가 되어버린다. 어떤 로직, 어떤 구조(인프라)를 구축할 수 있을까?
  - 이를 아래 항에서 자세히 기술해보자.

2. 빠르게
   - 흔히 말하는 **ETL**. **추출(Extract)**, **변환(Transform)**, **적재(Load)** 의 방식을 통해 데이터가 쌓이고 이 데이터를 사용자 요청에 따라 리턴한다.
   - 정상적인 데이터를 한 곳에만 쌓고 이를 그대로 되돌려주는 방식은 데이터가 쌓여감에 따라 성능 개선의 여지가 보일 수 있다.(느릴 수 있다.)
   - 그렇다면, 쌓여만 가는 데이터를 바라보는 상황에서 어떻게 빠른 속도를 구현할 수 있을까?
   - 이를 아래 항에서 자세히 기술해보자.

# Design

## Struct (Object)

데이터베이스(DB)에 저장될 데이터의 **Struct를 정확하게 정의해야 한다**. 정말 당연하게도 Name을 Age로 적는 경우는 안되니까 말이다.

```go
type User struct {
  Name string
}

type User struct {
  Age int
}
```

단, 최대한 DB에 들어갈 데이터의 Struct를 정확하게 하려해도 **네트워크 혹은 외부 API**에서 불러와지는 데이터가 이 구조체의 형식을 온전히 100% 만족하는지는 각 **서비스 자체에 의존성이 있다**.
서비스 버전 **v1** 가 **v2**로 버전 업그레이드가 되었다던가, **PoW** 합의가 **PoS** 합의로 변경되었다던가 하는 경우 데이터 Struct 자체가 변경될 수 있고, 해당 변경점을 서비스 주체자가 아닌 내가 뭐 어떻게 할 수 없다는 소리이다.

**=> 최대한 데이터 Struct 를 정확하게 구현하자. 데이터 자체에 변경점이 있고 이에 대한 대응을 구현 해야할 가능성이 존재함을 인지히자.**

## RDB

### 정규화 (Normalization)

블록체인 데이터에서 블록에는 여러 속성 값이 있고 그 중에는 트랜잭션 배열이 있다. 또한, 각 트랜잭션에는 또 여러 속성 값이 존재한다. 그리고 보통의 경우, 이러한 상황을 만족시키는 DB를 설계할 때 **정규화**의 과정을 진행한다.

- **정규화** : 블록, 트랜잭션 등 목적(N)에 따라 데이터를 잘 분류하고, 블록은 블록대로, 트랜잭션은 트랜잭션 대로 **스키마**(**테이블**)을 만들고 이들을 잘 연결하는(**모델링**) 과정. 중복 데이터를 없애는 과정이라고 말한다.
  - 예를 들어, 각각의 Name이 아닌 아예 같은 속성 Name이 여러 테이블에 존재한다면, 이들은 항상 같은 값(일관성, **Consistency**)을 유지해야한다. 어디서는 내가 **Bob**이고 어디서는 내가 **Alice**인 세계선은 혼란을 만들어내기 때문이다.

### 중복(보조) 테이블 혹은 비정규화

만약 내가 블록 데이터 속성들 중 유독 타임스탬프 값만 많이 사용되는 세계선에 있다고 해보자. 그리고 좀 더 빠른 성능을 바란다고 할 때 두 가지의 해결 방안을 떠올릴 수 있다.

1. 중복(보조) 테이블
   - 말 그대로 기존 블록 테이블도 존재하고, 속성 값에 타임스탬프만 존재하는 새로운 테이블을 하나 두는 것이다.
2. 비정규화
   - 비정규화가 테이블 아예 분리하는 거였나? 기억안나네 찾아보기
   - JOIN 이 많아(테이블들이 서로 많이 연결되어 있는) 이 조합을 좀 풀어내고 싶을 때 사용하는 경우이다.
